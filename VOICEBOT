import speech_recognition as sr
import pyttsx3
import openai
import os

openai.api_key = os.environ.get("Your_open_AI_API_key")

engine = pyttsx3.init()

def customize_tts():
    voices = engine.getProperty('voices')
    engine.setProperty('voice', voices[1].id) 
    engine.setProperty('rate', 150)
    engine.setProperty('volume', 1.0)

def speak(text):
    engine.say(text)
    engine.runAndWait()

def listen(recognizer, mic):
    with mic as source:
        print("Listening...")
        try:
            audio = recognizer.listen(source, timeout=5, phrase_time_limit=10)
            print("Recognizing...")
            text = recognizer.recognize_google(audio)
            print(f"You said: {text}")
            return text
        except sr.UnknownValueError:
            print("Sorry, I could not understand the audio.")
            speak("Sorry, I could not understand the audio.")
            return None
        except sr.RequestError:
            print("There was an error with the speech recognition service.")
            speak("There was an error with the speech recognition service.")
            return None
        except sr.WaitTimeoutError:
            print("You didn't say anything.")
            speak("You didn't say anything.")
            return None

# Listen with retry
def listen_with_retry(recognizer, mic, max_attempts=3):
    attempts = 0
    while attempts < max_attempts:
        user_input = listen(recognizer, mic)
        if user_input is not None:
            return user_input
        else:
            speak("I didn't catch that. Could you please try again?")
        attempts += 1
    return None

# # we can truncate a prompt for cost efficiency, if we want. i did it for testing 😁
# def truncate_prompt(prompt, max_words=100):
#     words = prompt.split()
#     if len(words) > max_words:
#         return " ".join(words[:max_words])
#     return prompt


def generate_response(prompt, message_history):
    try:
        # Append user message to history
        message_history.append({"role": "user", "content": prompt})

        # Get response from OpenAI
        response = openai.ChatCompletion.create(
            model="gpt-3.5-turbo",
            messages=message_history,
            request_timeout=10
        )

        # Extract and store assistant's reply
        reply = response['choices'][0]['message']['content']
        message_history.append({"role": "assistant", "content": reply})
        
                # Truncate history to the last N exchanges + system message
        MAX_HISTORY = 10
        if len(message_history) > 2 * MAX_HISTORY + 1:
            message_history = [message_history[0]] + message_history[-2 * MAX_HISTORY:]
            print("Notice: You have reached the memory limit. Old messages were removed.")
            speak("You've reached the memory limit. To keep things fast, I removed the oldest messages.")
            
        return reply
    except Exception as e:
        print(f"Error generating response: {e}")
        speak("There was an error generating a response.")
        return None


def main():
    message_history = [
    {"role": "system", "content": "You are a helpful and conversational voice assistant."}]
    # Call the function to customize TTS settings
    customize_tts()

    recognizer = sr.Recognizer()
    mic = sr.Microphone()

    with mic as source:
        print("Calibrating for ambient noise... please wait.")
        recognizer.adjust_for_ambient_noise(source, duration=1)
        print("Calibration complete.")
    speak("Hello! I am your assistant. How can I help you today?")
    while True:
        # Using the listen_with_retry function to allow retries
        user_input = listen_with_retry(recognizer, mic)
        if user_input:
            if user_input.lower() in ["exit", "quit", "stop", "bye", "goodbye"]:
                speak("Goodbye!")
                break       
            # short_prompt = truncate_prompt(user_input)
            # response = generate_response(short_prompt)
            response = generate_response(user_input, message_history)
            if response:
                print(f"Assistant: {response}")
                speak(response)


if __name__ == "__main__":
    main()
